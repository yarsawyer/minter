use std::sync::Arc;

use anyhow::Context;

use crate::{minter::{utxo::UtxoData, Minter}, subcommand::print_json, wallet::{AddressType, WalletAddressData}};


#[derive(serde::Serialize, serde::Deserialize)]
pub struct Output {
    utxo: Vec<OutputUtxoData>,
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OutputUtxoData {
    pub txid: String,
    pub vout: u32,
    pub confirmed: bool,
    pub value: f64,
}

#[derive(Debug, clap::Parser)]
pub struct ListUtxo {
    #[arg(help = "public wallet address to use (generated by receive)", required=false)]
    pub address: Option<String>,

    #[arg(short, help = "True to use only saved to DB data. False to fetch from api (and save to DB)")]
    pub cached: bool,
}

impl ListUtxo {
    pub async fn run(self, options: crate::subcommand::Options, state: Arc<Minter>) -> anyhow::Result<()> {
        let wallet_selector = |k: &str,x: &WalletAddressData|
            x.ty == AddressType::Utxo && (!self.address.as_deref().is_some_and(|addr| k.split('/').last().unwrap() != addr));
        let utxo_selector = |k: &str,x: &UtxoData|
            x.ty == AddressType::Utxo && (!self.address.as_deref().is_some_and(|addr| k.split('/').nth(1).unwrap() != addr));

        let utxo = if self.cached {
            state.get_all_utxo(&options.wallet, wallet_selector).context("Failed to load utxo's")?
        } else {
            state.fetch_utxo(&options.wallet, wallet_selector, utxo_selector).await.context("Failed to fetch utxo's")?
        };

        print_json(Output {
            utxo: utxo
                .iter()
                .map(|(_addr,x)| OutputUtxoData {
                    txid: x.txid.to_string(),
                    vout: x.vout,
                    confirmed: x.status.confirmed,
                    value: bitcoin::Amount::from_sat(x.value).to_btc(),
                })
                .collect(),
        }).unwrap();
        Ok(())
    }
}
